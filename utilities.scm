; ---------------------------------------------------------------------------- ;
; This file contains a function that can be used to print out the state table  ;
; stored in an LR-program record and another function that can be used to      ;
; reduce the size of an LR-program.                                            ;
; ---------------------------------------------------------------------------- ;
(define (print-LR-program program . place)
  (let ((port (cond ((null? place) (current-output-port))
		    ((not (null? (cdr place)))
		     (error "print-LR-program only accepts 2 arguments"))
		    ((output-port? (car place)) (car place))
		    ((string? (car place)) (open-output-file (car place)))
		    ((eq? #t (car place)) (current-output-port))
		    (else
		     (error "Unknown place to write states:" (car place)))))
	(num-states (vector-length (LR-program:states program))))
    (let loop ((i 0))
      (if (< i num-states)
	  (begin
	    (print-state i port program)
	    (loop (+ i 1)))))))

(define (print-state state-num port program)
  (let* ((display (lambda (what) (display what port)))
	 (newline (lambda () (newline port)))
	 (rules (LR-program:rules program))
	 (state (vector-ref (LR-program:states program) state-num)))
    (display "--------------------------------------------------") (newline)
    (display "State: ") (display state-num) (newline)
    (display "  Items:") (newline)
    (let loop ((items (reverse (LR-state:items state))))
      (if (pair? items)
	  (begin
	    (print-item (caar items) (vector-ref rules (caar items))
			(cdar items) display)
	    (newline)
	    (loop (cdr items)))))
    (display "  Shift/Reduce Table:") (newline)
    (let loop ((actions (LR-state:shift-reduce-table state)))
      (if (pair? actions)
	  (begin
	    (display "    ")
	    (cond ((eq? (caar actions) #t)
		   (display "Default: reduce ")
		   (display (caddar actions)))
		  ((eq? (cadar actions) 'accept)
		   (display (caar actions))
		   (display ": Accept"))
		  (else
		   (display (caar actions))
		   (display ": ")
		   (display (cadar actions))
		   (display " ")
		   (display (caddar actions))))
	    (newline)
	    (loop (cdr actions)))))
    (display "  Goto Table:") (newline)
    (let loop ((actions (LR-state:goto-table state)))
      (if (pair? actions)
	  (begin
	    (display "    ")
	    (display (caar actions))
	    (display ": goto ")
	    (display (caddar actions))
	    (newline)
	    (loop (cdr actions)))))
    (newline)))

(define (print-item rule-num rule dot-index display)
  (display "    ")
  (display rule-num)
  (display ": ")
  (display (LR-rule:left-side rule))
  (display " ->")
  (let* ((rhs (LR-rule:right-side rule))
	 (num-items (vector-length rhs)))
    (let loop ((i 0))
      (if (= i dot-index)
	  (display " ."))
      (if (< i num-items)
	  (begin
	    (display " ")
	    (display (vector-ref rhs i))
	    (loop (+ i 1)))))))

;-------------------------------------------------------------------------------
(define (write-program program place define-name action-write-func)
  (let* ((port (cond ((output-port? place) place)
		     ((string? place) (open-output-file place))
		     (else
		      (error "Unknown place to write states: " place))))
	 (display (lambda (what) (display what port)))
	 (newline (lambda () (newline port)))
	 (action-write-func (lambda (what) (action-write-func what port)))
	 (rules (LR-program:rules program))
	 (num-rules (vector-length rules))
	 (states (LR-program:states program))
	 (num-states (vector-length states)))
    (display "(define ")
    (display define-name)
    (newline)
    (display "(make-LR-program '")
    (display (LR-program:terminals program))
    (newline)
    (display "                 '")
    (display (LR-program:eoi program))
    (newline)
    (display "                 '")
    (display (LR-program:error program))
    (let loop ((i 0) (first-string  "                 (vector "))
      (if (< i num-rules)
	  (begin
	    (newline)
	    (display first-string)
	    (display "(make-LR-rule '")
	    (display (LR-rule:left-side (vector-ref rules i)))
	    (newline)
	    (display "                                       (vector")
	    (let* ((right-side (LR-rule:right-side (vector-ref rules i)))
		   (right-side-length (vector-length right-side)))
	      (let loop ((j 0))
		(if (< j right-side-length)
		    (begin
		      (display " '")
		      (display (vector-ref right-side j))
		      (loop (+ j 1))))))
	    (display ")")
	    (newline)
	    (display "                                       ")
	    (action-write-func (LR-rule:action (vector-ref rules i)))
	    (display ")")
	    (loop (+ i 1) "                         "))))
    (display ")")
    (let loop ((i 0) (first-string  "                 (vector "))
      (if (< i num-states)
	  (begin
	    (newline)
	    (display first-string)
	    (display "(make-LR-state '")
	    (display (LR-state:shift-reduce-table (vector-ref states i)))
	    (newline)
	    (display "                                        '")
	    (display (LR-state:goto-table (vector-ref states i)))
	    (newline)
	    (display "                                        '")
	    (display (LR-state:items (vector-ref states i)))
	    (display ")")
	    (loop (+ i 1) "                         "))))
    (display ")))")
    (newline)))
