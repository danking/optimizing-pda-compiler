(define (compile-actions-macro-strict form rename compare)
  (if (= (length form) 2)
      (compile-actions-hp (cadr form) rename)
      (error "compile-actions only accepts one argument")))

(define (compile-actions-macro-cps form rename compare)
  (if (>= (length form) 2)
      (append (cddr form) (list (compile-actions-hp (cadr form) rename)))
      (error "compile-actions only accepts one argument")))

(define (compile-actions-hp cfg-form rename)
  (map (lambda (cfg-item)
	 (if (and (list? cfg-item)
		  (or (eq? (car cfg-item) 'non-term)
		      (eq? (car cfg-item) 'NON-TERM)))
	     (map (lambda (non-term-item)
		    (if (and (list? non-term-item)
			     (eq? (car non-term-item) '=>))
			(compile-rule non-term-item rename)
			non-term-item))
		  cfg-item)
	     cfg-item))
       cfg-form))

(define (compile-rule rule rename)
  (if (not (member (length rule) '(3 4)))
      (error "Invalid rule declaration:" rule))
  (let* ((rule-len (length rule))
	 (prec (if (= rule-len 4) (second rule) #f))
	 (right-side (if (= rule-len 4) (third rule) (second rule)))
	 (action (if (= rule-len 4) (fourth rule) (third rule))))
    (let loop ((result '()) (params '()) (right-side right-side))
      (cond ((null? right-side)
	     `(=> ,@(if prec (list prec) '()) ,(reverse result)
		  ,(list (rename 'lambda) (number-params params) action)))
	    ((list? (car right-side))
	     (if (= (length (car right-side)) 2)
		 (loop (cons (cadar right-side) result)
		       (cons (caar right-side) params)
		       (cdr right-side))
		 (error "Right-side name binding can only contain two elements.")))
	    (else
	     (loop (cons (car right-side) result)
		   (cons (car right-side) params)
		   (cdr right-side)))))))

(define (number-params params)
  (let ((table (make-symbol-table)))
    (for-each (lambda (item)
		(let ((num (table-ref table item)))
		  (cond ((number? num)
			 (table-set! table item (+ num 1)))
			(num
			 (table-set! table item 2))
			(else
			 (table-set! table item #t)))))
	      params)
    (fold (lambda (item result)
	    (let ((num (table-ref table item)))
	      (if (number? num)
		  (begin
		    (table-set! table item (- num 1))
		    (cons (string->symbol (string-append (symbol->string item)
							 "-"
							 (number->string num)))
			  result))
		  (cons item result))))
	  '() params)))
