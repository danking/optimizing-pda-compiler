(define-record reg-production
  lhs
  size)

(define (gen-starter)
  (display ".data")
  (newline))
(define (gen-spim-list prefix red-tab)
  (display prefix)
  (display "RuleToLength:")
  (display ".word 0")
  (newline)
  (let loop1 ((n 1))
    (if (<= n (length red-tab)) 
	(let ((r (cdr (assoc n red-tab))))
	  (display ".word ")
	  (display (reg-production:size r))
	  (newline)
	  (loop1 (+ n 1)))))
  (display prefix)
  (display "RuleToNT:")
  (display ".word 0")
  (newline)
  (let loop2 ((n 1))
    (if (<= n (length red-tab)) 
	(let ((r (cdr (assoc n red-tab))))
	  (display ".word ")
	  (display (reg-production:lhs r))
	  (newline)
	  (loop2 (+ n 1))))))
(define (gen-spim-table prefix tc ntc sc)
  (display prefix)
  (display "ActionTable:")
  (let os1 ((n 0))
	(if (< n sc)
	    (begin
	      (display ".word ")
	      (display prefix)
	      (display "ASR")
	      (display n)
	      (newline)
	      (os1 (+ n 1)))))
  (let os1.1 ((n 0))
    (if (< n sc)
	    (begin
	      (display prefix)
	      (display "ASR")
	      (display n)
	      (display ": .word")
	      (display  prefix)
	      (display "AS")
	      (display n)
	      (newline)
	      (os1.1 (+ n 1)))))
  (let os2 ((n 0)
	     (at tmp:action-table))
	(if (< n sc)
	    (begin
	      (display prefix)
	      (display "AS")
	      (display n)
	      (display ":")
	      (let is1 ((x 0))
		(if (< x tc)
		    (begin (display ".word ")
			   (let ((tmp  (assoc x (car at)))
				 (default (assoc 'default (car at))))
			     
			     (if tmp
				 (cond ((eq? 'accept (cdr tmp))
					(display (+ sc 1)))
				       ((eq? '*error* (cdr tmp))
					(display (+ sc 2)))
				       (else
					(display (cdr tmp))))
				 (cond ((eq? 'accept (cdr default))
					(display (+ sc 1)))
				       ((eq? '*error* (cdr default))
					(display (+ sc 2)))
				       (else
					(display (cdr default))))))
			   (newline)
			   (is1 (+ x 1)))))
	      (newline)
	      (os2 (+ n 1) (cdr at)))))
  (newline)
  (display prefix)
  (display "GotoTable:")
  (let og1 ((n 0))
	(if (< n sc)
	    (begin
	      (display ".word ")
	      (display prefix)
	      (display "GSR")
	      (display n)
	      (newline)
	      (og1 (+ n 1)))))
  (let og1.1 ((n 0))
    (if (< n sc)
	    (begin
	      (display prefix)
	      (display "GSR")
	      (display n)
	      (display ": .word")
	      (display  prefix)
	      (display "GS")
	      (display n)
	      (newline)
	      (og1.1 (+ n 1)))))
  (let og2 ((n 0)
	     (gt tmp:goto-table))
    (if (< n sc)
	(begin
	  (display prefix)
	  (display "GS")
	  (display n)
	  (display ":")
	  (let ig1 ((x 0))
	    (if (< x ntc)
		(begin 
		  (display ".word ")
		  (let ((tmp  (assoc x (car gt))))
		    (if tmp
			(display (cdr tmp))
			(display (+ sc 2))))
		  
		  (newline)
		  (ig1 (+ x 1)))))
	  (newline)
	  (og2 (+ n 1) (cdr gt))))))

  
(define (allocater sc)
  (display "")
)
(define (gen-red-table gram)
  (let loop ((gram gram)
	     (rule-no 1)
	     (ret  '()))
    (if (null? gram)
	ret
	(let ((nt (caar gram)))
	  (let i-loop ((rules (cdar gram))
		       (rule-no rule-no)
		       (ret ret))
	    (if (null? rules)
		(loop (cdr gram) rule-no ret)
		(i-loop (cdr rules) 
			(+ rule-no 1)
			(cons (cons rule-no
				    (make-reg-production nt 
							 (length 
							  (car rules))))
			      ret))))))))
	    
(define (generate-table prefix tc ntc sc)
 
  (let loop1 ((at tmp:action-table)
	      (s 0))
    
    (if (= s (length tmp:action-table))
	'()
	(begin
	  (display "function initState")
	  (display s)
	  (display "() = let in ")
	  (newline)
	  
	  (let loop2 ((n 0))
	    (if (= n tc)
		(loop1 (cdr at)
		       (+ s 1))
		(begin
		  
		  (display prefix)
		  (display "ActionTable[")
		  (display s)
		  (display "].a[")
		  (display n)
		  (display "] :=")
		  (let ((tmp  (assoc n (car at)))
			(default (assoc 'default (car at))))
		    
		    (if tmp
			(cond ((eq? 'accept (cdr tmp))
			       (display (+ sc 1)))
			      ((eq? '*error* (cdr tmp))
			       (display (+ sc 2)))
			      (else
			       (display (cdr tmp))))
			(cond ((eq? 'accept (cdr default))
			       (display (+ sc 1)))
			      ((eq? '*error* (cdr default))
			       (display (+ sc 2)))
			      (else
			       (display (cdr default)))))
		    
		    
		    (if (= (+ n 1) tc)
			(display " end")
			(display ";"))
		    (newline)
		    (loop2 (+ n 1)))))))))
  (let g-loop ((gt tmp:goto-table)
	       (s 0))
    
    (if (= s (length tmp:goto-table))
	'()
	(begin
	  (display "function GotoState")
	  (display s)
	  (display "() = let in ")
	  (newline)
	  
	  (let g-loop2 ((n 0))
	    (cond ((= n ntc)
		   (begin
		     (g-loop (cdr gt) (+ s 1))))
		  ((not (car gt))
		   (begin 
		     (g-loop (cdr gt) (+ s 1))))
		  (else
		   (begin
		     
		     (display prefix)
		     (display "GotoTable[")
		     (display s)
		     (display "].a[")
		     (display n)
		     (display "] :=")
		     (let ((tmp  (assoc n (car gt))))
		       (if tmp
			   (display (cdr tmp))
			   (display (+ sc 2))))
		     (if (= (+ n 1) ntc)
			 (display " end")
			  (display ";"))
		     
		     (newline)
		     (g-loop2 (+ n 1)))))))))
  (display "in")
  (newline)
  (let final-loop ((s 0))
    (if (= s (length tmp:action-table))
	'()
	  (begin
	    (display "initState")
	    (display s)
	    (display "()")
	    (display ";")
	    (newline)
	    (final-loop (+ s 1)))))
  (let final-loop1 ((s 0))
    (if (= s (length tmp:goto-table))
	'()
	(begin
	  (display "GotoState")
	  (display s)
	  (display "()")
	  (if (= (+ s 1) (length tmp:goto-table))
	      (display "")
	      (display ";"))
	  (newline)
	  (final-loop1 (+ s 1)))))
  (display "end")
  (newline))
(define (output-red-list red-tab prefix)
  (display "function ")
  (display prefix)
  (display "InitRed() = ")
  (newline)
  (display "let in")
  (newline)
  (let loop ((n 1))
    
    (if (> n (length red-tab))
	(display "end")
	(let ((r (cdr (assoc n red-tab))))
	    (display prefix)
	    (display "RuleToLength[")
	    (display n)
	    (display "] :=")
	    (display (reg-production:size r))
	    (display " ;")
	    (newline)
	    (display prefix)
	    (display "RuleToNT[")
	    (display n)
	    (display "] :=")
	    (display (reg-production:lhs r))
	    (if (< n (length red-tab))
		(display " ;"))
	    (newline)
	    (loop (+ n 1))))))

  
		    
(define (pda-gen-lalr1 my-grammar file prefix)
  (gen-lalr1 my-grammar file 'tmp)
  (load file)
  (let ((sc (length tmp:action-table))
	(tc (length (vector->list the-terminals)))
	(ntc (length (vector->list the-nonterminals)))
	(red-table (gen-red-table grammar)))
    (with-output-to-file 
     file
     (lambda ()
       (gen-starter)
       (gen-spim-list prefix red-table)
       (gen-spim-table prefix tc ntc sc)))))
       