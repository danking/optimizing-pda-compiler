(define (output-action-table prefix)
  (display "(define ") (display prefix) (display "action-table") (newline)
  (display "  '(") (newline)
  (do ((i 0 (+ i 1)))
      ((= i nstates))
    (display "     ")
    (write (vector-ref action-table i))
    (newline))
  (display "    ))") (newline)
  (newline))

(define (output-goto-table prefix)
  (display "(define ") (display prefix) (display "goto-table") (newline)
  (display "  '(") (newline)
  (do ((i 0 (+ i 1)))
      ((= i nstates))
    (display "     ") 
    (let ((shifts (vector-ref shift-table i)))
      (if shifts
	  (begin
	    (display "(")
	    (let loop ((l (shift-shifts shifts)))
	      (if (null? l)
		  (display ")")
		  (let* ((state (car l))
			 (symbol (vector-ref acces-symbol state)))
		    (if (< symbol nvars)
			(display `(,symbol . ,state)))
		    (loop (cdr l))))))
	  (display '())))
    (newline))
  (display "    ))") (newline)
  (newline))

(define (output-reduction-table gram/actions prefix)
  (display "(define ") (display prefix) (display "reduction-table") (newline)
  (display "  (vector") (newline)
  (display "    '()") (newline)
  (for-each
   (lambda (p)
     (let ((act (cdr p)))
       (display "    (lambda (stack sp goto-table)") (newline)
       (let* ((nt (caar p)) (rhs (cdar p)) (n (length rhs)))
	 (display "      (let* (")
	 (if act
	     (let loop ((i 1) (l rhs))
	       (if (not (null? l))
		   (let ((rest (cdr l)))
		     (if (> i 1) (begin (newline) (display "             ")))
		     (display "($") (display (+ (- n i) 1)) (display " ")
		     (display "(vector-ref stack (- sp ")
		     (display (- (* i 2) 1))
		     (display ")))")
		     (loop (+ i 1) rest)))))
	 (display ")")
	 (newline)
	 (display "          ")
	 (if (= nt 0)
	     (display "(accept $1)")
	     (begin
	       (display "(push stack (- sp ")
	       (display (* 2 n))
	       (display ") ")
	       (display nt)
	       (display " goto-table ")
	       (write (cdr p))
	       (display ")")))
	 (display "))") (newline))))
   gram/actions)
  (display "  ))") (newline)
  (newline))

(define (output-parser-def parser-prefix prefix)
  (display "(define ") (display parser-prefix) (display "parser") (newline)
  (display "   (make-parser") (newline)
  (display "    ") (display prefix) (display "action-table") (newline)
  (display "    ") (display prefix) (display "goto-table") (newline)
  (display "    ") (display prefix) (display "reduction-table") (newline)
  (display "    ") (display prefix) (display "token-defs))") (newline))
  

(define (output-token-defs terms prefix)
  (let loop ((i 0) (l terms))
    (if (pair? l)
	(let ((x (car l)))
	  (display "(define ") (display prefix)
	  (write x) (display "-tok")
	  (display #\space)
	  (display i)
	  (display ")")
	  (newline)
	  (loop (+ i 1) (cdr l)))))
  (newline)
  (display "(define ") (display prefix) (display "token-defs") (newline)
  (display "  (list ") (newline)
  (let loop ((i 0) (l terms))
    (if (pair? l)
	(begin
	  (display "   (cons ")
	  (display i)
	  (display " \"") (display (car l)) (display "\")")
	  (newline)
	  (loop (+ i 1) (cdr l)))))
  (display "  ))") (newline)
  (newline))

(define (output-to-file output-file opt) 
  (let* ((parser-name (if (and (pair? opt) (symbol? (car opt))) 
			  (car opt) #f))
	 (prefix      (if parser-name 
			  (string-append
			   (symbol->string parser-name)
			   ":")
			  ""))
	 (parser-prefix (if parser-name
			    (string-append (symbol->string parser-name) 
					   "-")
			    "")) )
    (with-output-to-file output-file
      (lambda ()
	(display "; *** Token Definitions ***")
	(newline)
	(output-token-defs global-terms prefix)
	(display "; *** Action Table ***")
	(newline)
	(output-action-table prefix)
	(display "; *** Goto Table ***")
	(newline)
	(output-goto-table prefix)
	(display "; *** Reduction Table ***")
	(newline)
					; (output-reduction-table gram/actions prefix)
	(display "; *** Parser Definition ***")
	(newline)
					;  (output-parser-def parser-prefix prefix)
	))) )
