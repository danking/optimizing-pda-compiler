let 
var x := 0

var tigerStackPtr := -1
var tigerTsPtr := 0

/* state 0

   *start* --> . program *EOI*    (rule 1)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState0(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  1 (
<| tigerState17(s, sp, ts, tsp) | #1  |>

)  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState15(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 1

   exp --> MINUS . exp    (rule 35)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState1(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState18(s, sp, ts, tsp) | #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 2

   exp --> NIL .    (rule 38)

   default action : reduce using rule 38


*/
function tigerState2(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -0;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 3

   exp --> BREAK .    (rule 37)

   default action : reduce using rule 37


*/
function tigerState3(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -0;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 4

   exp --> LET . decls IN expseq END    (rule 28)

   default action : reduce using rule 4


*/
function tigerState4(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  2 (
<| tigerState19(s, sp, ts, tsp) | #1 , tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
 in case (tigerTS[ tsp ]) of default ( sp := sp + 1; 
tigerStack[ sp ] := 2 ;<| goto (tsp) |  #1  |>)   end

end
/* state 5

   exp --> FOR . ID ASSIGN exp TO exp DO exp    (rule 25)

   default action : Error
   ID : shift and goto state 20


*/
function tigerState5(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState20(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 6

   exp --> WHILE . exp DO exp    (rule 24)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState6(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState21(s, sp, ts, tsp) | #1 , tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 7

   exp --> IF . exp THEN exp ELSE exp    (rule 22)
   exp --> IF . exp THEN exp    (rule 23)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState7(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState22(s, sp, ts, tsp) | #1 , tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 8

   exp --> LPAREN . expseq RPAREN    (rule 34)

   default action : reduce using rule 46
   RPAREN : reduce using rule 44


*/
function tigerState8(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  15 (
<| tigerState24(s, sp, ts, tsp) | #1  |>

)  16 (
<| tigerState23(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 8 (
( sp := sp + 1; 
tigerStack[ sp ] := 15 ;<| goto (tsp) | #1 |>) )default ( sp := sp + 1;
tigerStack[ sp ] := 16 ;<| goto (tsp) |  #1  |>)   end

end
/* state 9

   exp --> STRING .    (rule 32)

   default action : reduce using rule 32


*/
function tigerState9(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -0;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 10

   exp --> INT .    (rule 31)

   default action : reduce using rule 31


*/
function tigerState10(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -0;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 11

   idbrack --> ID . LBRACK exp RBRACK    (rule 21)
   exp --> ID . LPAREN args RPAREN    (rule 29)
   exp --> ID . LBRACE fieldassigns RBRACE    (rule 36)
   lvalue --> ID .    (rule 64)
   lvaluea --> ID . DOT ID    (rule 66)

   default action : reduce using rule 64
   LPAREN : shift and goto state 28
   LBRACK : shift and goto state 27
   LBRACE : shift and goto state 26
   DOT : shift and goto state 25


*/
function tigerState11(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 13 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState25(s, sp, ts, tsp) | #1  |>
))  11 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState26(s, sp, ts, tsp) | #1  |>
))  9 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState27(s, sp, ts, tsp) | #1  |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState28(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 0 ;
tigerStack[ sp ] := 21; <| tsp | #1 |> )  end


end
/* state 12

   lvalue --> lvaluea .    (rule 65)
   lvaluea --> lvaluea . DOT ID    (rule 68)
   lvaluea --> lvaluea . LBRACK exp RBRACK    (rule 69)

   default action : reduce using rule 65
   LBRACK : shift and goto state 30
   DOT : shift and goto state 29


*/
function tigerState12(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 13 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState29(s, sp, ts, tsp) | #1  |>
))  9 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState30(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 0 ;
tigerStack[ sp ] := 21; <| tsp | #1 |> )  end


end
/* state 13

   exp --> lvalue . ASSIGN exp    (rule 26)
   exp --> lvalue .    (rule 30)

   default action : reduce using rule 30
   ASSIGN : shift and goto state 31


*/
function tigerState13(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 30 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState31(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 0 ;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 14

   exp --> binop .    (rule 33)

   default action : reduce using rule 33


*/
function tigerState14(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -0;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 15

   program --> exp .    (rule 2)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 2
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState15(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 0 ;
tigerStack[ sp ] := 1; <| tsp | #1 |> )  end


end
/* state 16

   exp --> idbrack . OF exp    (rule 27)
   lvaluea --> idbrack .    (rule 67)

   default action : reduce using rule 67
   OF : shift and goto state 44


*/
function tigerState16(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 31 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState44(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 0 ;
tigerStack[ sp ] := 22; <| tsp | #1 |> )  end


end
/* state 17

   *start* --> program . *EOI*    (rule 1)

   default action : Error
   *EOI* : shift and goto state 45


*/
function tigerState17(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 0 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState45(s, sp, ts, tsp) | #1 , tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 18

   exp --> MINUS exp .    (rule 35)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 35


*/
function tigerState18(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -1;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 19

   decls --> decls . decl    (rule 3)
   exp --> LET decls . IN expseq END    (rule 28)

   default action : Error
   IN : shift and goto state 49
   FUNCTION : shift and goto state 48
   VAR : shift and goto state 47
   TYPE : shift and goto state 46


*/
function tigerState19(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  3 (
<| tigerState53(s, sp, ts, tsp) | #2  |>

)  4 (
<| tigerState52(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1,  #2  |>    |>

)  9 (
<| tigerState51(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1,  #2  |>    |>

)  10 (
<| tigerState50(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1,  #2  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 26 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState46(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1,  #2  |>    |>
))  25 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState47(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1,  #2  |>    |>
))  24 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState48(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1,  #2  |>    |>
))  20 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState49(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 20

   exp --> FOR ID . ASSIGN exp TO exp DO exp    (rule 25)

   default action : Error
   ASSIGN : shift and goto state 54


*/
function tigerState20(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 30 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState54(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 21

   exp --> WHILE exp . DO exp    (rule 24)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : Error
   DO : shift and goto state 55
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState21(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #2  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #2  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #2  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #2  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #2  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #2  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #2  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #2  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #2  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #2  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #2  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #2  |>
))  29 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState55(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 22

   exp --> IF exp . THEN exp ELSE exp    (rule 22)
   exp --> IF exp . THEN exp    (rule 23)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : Error
   THEN : shift and goto state 56
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState22(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #2  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #2  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #2  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #2  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #2  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #2  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #2  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #2  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #2  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #2  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #2  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #2  |>
))  27 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState56(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 23

   expseq --> expseqsemi . exp    (rule 43)
   expseqsemi --> expseqsemi . exp SEMICOLON    (rule 45)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState23(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState57(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 24

   exp --> LPAREN expseq . RPAREN    (rule 34)

   default action : Error
   RPAREN : shift and goto state 58


*/
function tigerState24(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 8 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState58(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 25

   lvaluea --> ID DOT . ID    (rule 66)

   default action : Error
   ID : shift and goto state 59


*/
function tigerState25(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState59(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 26

   exp --> ID LBRACE . fieldassigns RBRACE    (rule 36)

   default action : reduce using rule 60
   ID : reduce using rule 62


*/
function tigerState26(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  18 (
<| tigerState61(s, sp, ts, tsp) | #1  |>

)  19 (
<| tigerState60(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; 
tigerStack[ sp ] := 19 ;<| goto (tsp) | #1 |>) )default ( sp := sp + 1;
tigerStack[ sp ] := 18 ;<| goto (tsp) |  #1  |>)   end

end
/* state 27

   idbrack --> ID LBRACK . exp RBRACK    (rule 21)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState27(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState62(s, sp, ts, tsp) | #1 , tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 28

   exp --> ID LPAREN . args RPAREN    (rule 29)

   default action : reduce using rule 42
   RPAREN : reduce using rule 40


*/
function tigerState28(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  13 (
<| tigerState64(s, sp, ts, tsp) | #1  |>

)  14 (
<| tigerState63(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 8 (
( sp := sp + 1; 
tigerStack[ sp ] := 13 ;<| goto (tsp) | #1 |>) )default ( sp := sp + 1;
tigerStack[ sp ] := 14 ;<| goto (tsp) |  #1  |>)   end

end
/* state 29

   lvaluea --> lvaluea DOT . ID    (rule 68)

   default action : Error
   ID : shift and goto state 65


*/
function tigerState29(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState65(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 30

   lvaluea --> lvaluea LBRACK . exp RBRACK    (rule 69)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState30(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState66(s, sp, ts, tsp) | #1 , tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 31

   exp --> lvalue ASSIGN . exp    (rule 26)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState31(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState67(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 32

   binop --> exp DIVIDE . exp    (rule 50)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState32(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState68(s, sp, ts, tsp) | #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 33

   binop --> exp TIMES . exp    (rule 49)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState33(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState69(s, sp, ts, tsp) | #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 34

   binop --> exp PLUS . exp    (rule 47)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState34(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState70(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 35

   binop --> exp MINUS . exp    (rule 48)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState35(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState71(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 36

   binop --> exp GE . exp    (rule 54)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState36(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState72(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 37

   binop --> exp GT . exp    (rule 55)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState37(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState73(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 38

   binop --> exp LE . exp    (rule 52)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState38(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState74(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 39

   binop --> exp LT . exp    (rule 51)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState39(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState75(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 40

   binop --> exp NEQ . exp    (rule 56)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState40(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState76(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 41

   binop --> exp EQ . exp    (rule 53)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState41(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState77(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 42

   binop --> exp AND . exp    (rule 57)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState42(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState78(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 43

   binop --> exp OR . exp    (rule 58)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState43(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState79(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 44

   exp --> idbrack OF . exp    (rule 27)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState44(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState80(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 45

   *start* --> program *EOI* .    (rule 1)

   default action : reduce using rule 1
   *EOI* : Accept input


*/
function tigerState45(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 0 (
<| 1 | #1 |>
)default ( sp := sp - 0 ;
tigerStack[ sp ] := 0; <| tsp | #2 |> )  end


end
/* state 46

   tydec --> TYPE . ID EQ ty    (rule 8)

   default action : Error
   ID : shift and goto state 81


*/
function tigerState46(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState81(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 47

   vardec --> VAR . ID COLON ID ASSIGN exp    (rule 17)
   vardec --> VAR . ID ASSIGN exp    (rule 18)

   default action : Error
   ID : shift and goto state 82


*/
function tigerState47(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState82(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 48

   fundec --> FUNCTION . ID LPAREN tyfields RPAREN EQ exp    (rule 19)
   fundec --> FUNCTION . ID LPAREN tyfields RPAREN COLON ID EQ exp    (rule 20)

   default action : Error
   ID : shift and goto state 83


*/
function tigerState48(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState83(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 49

   exp --> LET decls IN . expseq END    (rule 28)

   default action : reduce using rule 46
   END : reduce using rule 44


*/
function tigerState49(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  15 (
<| tigerState84(s, sp, ts, tsp) | #1  |>

)  16 (
<| tigerState23(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 21 (
( sp := sp + 1; 
tigerStack[ sp ] := 15 ;<| goto (tsp) | #1 |>) )default ( sp := sp + 1;
tigerStack[ sp ] := 16 ;<| goto (tsp) |  #1  |>)   end

end
/* state 50

   decl --> fundec .    (rule 7)

   default action : reduce using rule 7


*/
function tigerState50(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -0;
tigerStack[ sp ] := 3; <| tsp | #1 |> )  end


end
/* state 51

   decl --> vardec .    (rule 6)

   default action : reduce using rule 6


*/
function tigerState51(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -0;
tigerStack[ sp ] := 3; <| tsp | #1 |> )  end


end
/* state 52

   decl --> tydec .    (rule 5)

   default action : reduce using rule 5


*/
function tigerState52(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -0;
tigerStack[ sp ] := 3; <| tsp | #1 |> )  end


end
/* state 53

   decls --> decls decl .    (rule 3)

   default action : reduce using rule 3


*/
function tigerState53(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -1;
tigerStack[ sp ] := 2; <| tsp | #1 |> )  end


end
/* state 54

   exp --> FOR ID ASSIGN . exp TO exp DO exp    (rule 25)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState54(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState85(s, sp, ts, tsp) | #1 , tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 55

   exp --> WHILE exp DO . exp    (rule 24)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState55(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState86(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 56

   exp --> IF exp THEN . exp ELSE exp    (rule 22)
   exp --> IF exp THEN . exp    (rule 23)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState56(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState87(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 57

   expseq --> expseqsemi exp .    (rule 43)
   expseqsemi --> expseqsemi exp . SEMICOLON    (rule 45)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 43
   SEMICOLON : shift and goto state 88
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState57(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
))  6 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState88(s, sp, ts, tsp) | #2  |>
) )default ( sp := sp - 1 ;
tigerStack[ sp ] := 15; <| tsp | #2 |> )  end


end
/* state 58

   exp --> LPAREN expseq RPAREN .    (rule 34)

   default action : reduce using rule 34


*/
function tigerState58(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 59

   lvaluea --> ID DOT ID .    (rule 66)

   default action : reduce using rule 66


*/
function tigerState59(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 22; <| tsp | #1 |> )  end


end
/* state 60

   fieldassigns --> fieldassignscomma . fieldassign    (rule 59)
   fieldassignscomma --> fieldassignscomma . fieldassign COMMA    (rule 61)

   default action : Error
   ID : shift and goto state 89


*/
function tigerState60(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  20 (
<| tigerState90(s, sp, ts, tsp) | #1  |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState89(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 61

   exp --> ID LBRACE fieldassigns . RBRACE    (rule 36)

   default action : Error
   RBRACE : shift and goto state 91


*/
function tigerState61(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 12 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState91(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 62

   idbrack --> ID LBRACK exp . RBRACK    (rule 21)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : Error
   RBRACK : shift and goto state 92
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState62(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #2  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #2  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #2  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #2  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #2  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #2  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #2  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #2  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #2  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #2  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #2  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #2  |>
))  10 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState92(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 63

   args --> argscomma . exp    (rule 39)
   argscomma --> argscomma . exp COMMA    (rule 41)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState63(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState93(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 64

   exp --> ID LPAREN args . RPAREN    (rule 29)

   default action : Error
   RPAREN : shift and goto state 94


*/
function tigerState64(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 8 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState94(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 65

   lvaluea --> lvaluea DOT ID .    (rule 68)

   default action : reduce using rule 68


*/
function tigerState65(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 22; <| tsp | #1 |> )  end


end
/* state 66

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)
   lvaluea --> lvaluea LBRACK exp . RBRACK    (rule 69)

   default action : Error
   RBRACK : shift and goto state 95
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState66(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #2  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #2  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #2  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #2  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #2  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #2  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #2  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #2  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #2  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #2  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #2  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #2  |>
))  10 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState95(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 67

   exp --> lvalue ASSIGN exp .    (rule 26)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 26
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35
   GE : shift and goto state 36
   GT : shift and goto state 37
   LE : shift and goto state 38
   LT : shift and goto state 39
   NEQ : shift and goto state 40
   EQ : shift and goto state 41
   AND : shift and goto state 42
   OR : shift and goto state 43


*/
function tigerState67(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 12; <| tsp | #2 |> )  end


end
/* state 68

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp DIVIDE exp .    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 50


*/
function tigerState68(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 17; <| tsp | #1 |> )  end


end
/* state 69

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp TIMES exp .    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 49


*/
function tigerState69(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 17; <| tsp | #1 |> )  end


end
/* state 70

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp PLUS exp .    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 47
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33


*/
function tigerState70(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 17; <| tsp | #2 |> )  end


end
/* state 71

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp MINUS exp .    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 48
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33


*/
function tigerState71(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 17; <| tsp | #2 |> )  end


end
/* state 72

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp GE exp .    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 54
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35


*/
function tigerState72(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 17; <| tsp | #2 |> )  end


end
/* state 73

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp GT exp .    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 55
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35


*/
function tigerState73(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 17; <| tsp | #2 |> )  end


end
/* state 74

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp LE exp .    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 52
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35


*/
function tigerState74(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 17; <| tsp | #2 |> )  end


end
/* state 75

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp LT exp .    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 51
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35


*/
function tigerState75(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 17; <| tsp | #2 |> )  end


end
/* state 76

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp NEQ exp .    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 56
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35
   GE : shift and goto state 36
   GT : shift and goto state 37
   LE : shift and goto state 38
   LT : shift and goto state 39
   NEQ : Error
   EQ : Error


*/
function tigerState76(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 34 (
(print("Error Unknown "); exit(0); 0)
)  35 (
(print("Error Unknown "); exit(0); 0)
)  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 17; <| tsp | #2 |> )  end


end
/* state 77

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp EQ exp .    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 53
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35
   GE : shift and goto state 36
   GT : shift and goto state 37
   LE : shift and goto state 38
   LT : shift and goto state 39
   NEQ : Error
   EQ : Error


*/
function tigerState77(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 34 (
(print("Error Unknown "); exit(0); 0)
)  35 (
(print("Error Unknown "); exit(0); 0)
)  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 17; <| tsp | #2 |> )  end


end
/* state 78

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp AND exp .    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 57
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35
   GE : shift and goto state 36
   GT : shift and goto state 37
   LE : shift and goto state 38
   LT : shift and goto state 39
   NEQ : shift and goto state 40
   EQ : shift and goto state 41


*/
function tigerState78(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 17; <| tsp | #2 |> )  end


end
/* state 79

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)
   binop --> exp OR exp .    (rule 58)

   default action : reduce using rule 58
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35
   GE : shift and goto state 36
   GT : shift and goto state 37
   LE : shift and goto state 38
   LT : shift and goto state 39
   NEQ : shift and goto state 40
   EQ : shift and goto state 41
   AND : shift and goto state 42


*/
function tigerState79(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 17; <| tsp | #2 |> )  end


end
/* state 80

   exp --> idbrack OF exp .    (rule 27)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 27
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35
   GE : shift and goto state 36
   GT : shift and goto state 37
   LE : shift and goto state 38
   LT : shift and goto state 39
   NEQ : shift and goto state 40
   EQ : shift and goto state 41
   AND : shift and goto state 42
   OR : shift and goto state 43


*/
function tigerState80(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 12; <| tsp | #2 |> )  end


end
/* state 81

   tydec --> TYPE ID . EQ ty    (rule 8)

   default action : Error
   EQ : shift and goto state 96


*/
function tigerState81(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState96(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 82

   vardec --> VAR ID . COLON ID ASSIGN exp    (rule 17)
   vardec --> VAR ID . ASSIGN exp    (rule 18)

   default action : Error
   COLON : shift and goto state 98
   ASSIGN : shift and goto state 97


*/
function tigerState82(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 30 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState97(s, sp, ts, tsp) | #1  |>
))  5 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState98(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 83

   fundec --> FUNCTION ID . LPAREN tyfields RPAREN EQ exp    (rule 19)
   fundec --> FUNCTION ID . LPAREN tyfields RPAREN COLON ID EQ exp    (rule 20)

   default action : Error
   LPAREN : shift and goto state 99


*/
function tigerState83(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState99(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 84

   exp --> LET decls IN expseq . END    (rule 28)

   default action : Error
   END : shift and goto state 100


*/
function tigerState84(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 21 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState100(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 85

   exp --> FOR ID ASSIGN exp . TO exp DO exp    (rule 25)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : Error
   TO : shift and goto state 101
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState85(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #2  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #2  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #2  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #2  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #2  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #2  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #2  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #2  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #2  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #2  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #2  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #2  |>
))  18 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState101(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 86

   exp --> WHILE exp DO exp .    (rule 24)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 24
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35
   GE : shift and goto state 36
   GT : shift and goto state 37
   LE : shift and goto state 38
   LT : shift and goto state 39
   NEQ : shift and goto state 40
   EQ : shift and goto state 41
   AND : shift and goto state 42
   OR : shift and goto state 43


*/
function tigerState86(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 3 ;
tigerStack[ sp ] := 12; <| tsp | #2 |> )  end


end
/* state 87

   exp --> IF exp THEN exp . ELSE exp    (rule 22)
   exp --> IF exp THEN exp .    (rule 23)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 23
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35
   GE : shift and goto state 36
   GT : shift and goto state 37
   LE : shift and goto state 38
   LT : shift and goto state 39
   NEQ : shift and goto state 40
   EQ : shift and goto state 41
   AND : shift and goto state 42
   OR : shift and goto state 43
   ELSE : shift and goto state 102


*/
function tigerState87(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 28 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState102(s, sp, ts, tsp) | #2  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 3 ;
tigerStack[ sp ] := 12; <| tsp | #2 |> )  end


end
/* state 88

   expseqsemi --> expseqsemi exp SEMICOLON .    (rule 45)

   default action : reduce using rule 45


*/
function tigerState88(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 16; <| tsp | #1 |> )  end


end
/* state 89

   fieldassign --> ID . EQ exp    (rule 63)

   default action : Error
   EQ : shift and goto state 103


*/
function tigerState89(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState103(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 90

   fieldassigns --> fieldassignscomma fieldassign .    (rule 59)
   fieldassignscomma --> fieldassignscomma fieldassign . COMMA    (rule 61)

   default action : reduce using rule 59
   COMMA : shift and goto state 104


*/
function tigerState90(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 4 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState104(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 1 ;
tigerStack[ sp ] := 18; <| tsp | #1 |> )  end


end
/* state 91

   exp --> ID LBRACE fieldassigns RBRACE .    (rule 36)

   default action : reduce using rule 36


*/
function tigerState91(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -3;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 92

   idbrack --> ID LBRACK exp RBRACK .    (rule 21)

   default action : reduce using rule 21


*/
function tigerState92(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -3;
tigerStack[ sp ] := 11; <| tsp | #1 |> )  end


end
/* state 93

   args --> argscomma exp .    (rule 39)
   argscomma --> argscomma exp . COMMA    (rule 41)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 39
   COMMA : shift and goto state 105
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState93(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
))  4 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState105(s, sp, ts, tsp) | #2  |>
) )default ( sp := sp - 1 ;
tigerStack[ sp ] := 13; <| tsp | #2 |> )  end


end
/* state 94

   exp --> ID LPAREN args RPAREN .    (rule 29)

   default action : reduce using rule 29


*/
function tigerState94(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -3;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 95

   lvaluea --> lvaluea LBRACK exp RBRACK .    (rule 69)

   default action : reduce using rule 69


*/
function tigerState95(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -3;
tigerStack[ sp ] := 22; <| tsp | #1 |> )  end


end
/* state 96

   tydec --> TYPE ID EQ . ty    (rule 8)

   default action : Error
   ID : shift and goto state 108
   LBRACE : shift and goto state 107
   ARRAY : shift and goto state 106


*/
function tigerState96(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  5 (
<| tigerState109(s, sp, ts, tsp) | #1  |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 14 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState106(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  11 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState107(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState108(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 97

   vardec --> VAR ID ASSIGN . exp    (rule 18)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState97(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState110(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 98

   vardec --> VAR ID COLON . ID ASSIGN exp    (rule 17)

   default action : Error
   ID : shift and goto state 111


*/
function tigerState98(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState111(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 99

   fundec --> FUNCTION ID LPAREN . tyfields RPAREN EQ exp    (rule 19)
   fundec --> FUNCTION ID LPAREN . tyfields RPAREN COLON ID EQ exp    (rule 20)

   default action : reduce using rule 13
   ID : reduce using rule 15


*/
function tigerState99(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  6 (
<| tigerState113(s, sp, ts, tsp) | #1  |>

)  7 (
<| tigerState112(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; 
tigerStack[ sp ] := 7 ;<| goto (tsp) | #1 |>) )default ( sp := sp + 1;
tigerStack[ sp ] := 6 ;<| goto (tsp) |  #1  |>)   end

end
/* state 100

   exp --> LET decls IN expseq END .    (rule 28)

   default action : reduce using rule 28


*/
function tigerState100(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -4;
tigerStack[ sp ] := 12; <| tsp | #1 |> )  end


end
/* state 101

   exp --> FOR ID ASSIGN exp TO . exp DO exp    (rule 25)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState101(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState114(s, sp, ts, tsp) | #1 , tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 102

   exp --> IF exp THEN exp ELSE . exp    (rule 22)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState102(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState115(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 103

   fieldassign --> ID EQ . exp    (rule 63)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState103(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState116(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 104

   fieldassignscomma --> fieldassignscomma fieldassign COMMA .    (rule 61)

   default action : reduce using rule 61


*/
function tigerState104(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 19; <| tsp | #1 |> )  end


end
/* state 105

   argscomma --> argscomma exp COMMA .    (rule 41)

   default action : reduce using rule 41


*/
function tigerState105(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 14; <| tsp | #1 |> )  end


end
/* state 106

   ty --> ARRAY . OF ID    (rule 11)

   default action : Error
   OF : shift and goto state 117


*/
function tigerState106(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 31 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState117(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 107

   ty --> LBRACE . tyfields RBRACE    (rule 10)

   default action : reduce using rule 13
   ID : reduce using rule 15


*/
function tigerState107(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  6 (
<| tigerState118(s, sp, ts, tsp) | #1  |>

)  7 (
<| tigerState112(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; 
tigerStack[ sp ] := 7 ;<| goto (tsp) | #1 |>) )default ( sp := sp + 1;
tigerStack[ sp ] := 6 ;<| goto (tsp) |  #1  |>)   end

end
/* state 108

   ty --> ID .    (rule 9)

   default action : reduce using rule 9


*/
function tigerState108(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -0;
tigerStack[ sp ] := 5; <| tsp | #1 |> )  end


end
/* state 109

   tydec --> TYPE ID EQ ty .    (rule 8)

   default action : reduce using rule 8


*/
function tigerState109(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -3;
tigerStack[ sp ] := 4; <| tsp | #1 |> )  end


end
/* state 110

   vardec --> VAR ID ASSIGN exp .    (rule 18)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 18
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState110(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 3 ;
tigerStack[ sp ] := 9; <| tsp | #2 |> )  end


end
/* state 111

   vardec --> VAR ID COLON ID . ASSIGN exp    (rule 17)

   default action : Error
   ASSIGN : shift and goto state 119


*/
function tigerState111(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 30 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState119(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 112

   tyfields --> tyfieldscomma . tyfield    (rule 12)
   tyfieldscomma --> tyfieldscomma . tyfield COMMA    (rule 14)

   default action : Error
   ID : shift and goto state 120


*/
function tigerState112(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  8 (
<| tigerState121(s, sp, ts, tsp) | #1  |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState120(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 113

   fundec --> FUNCTION ID LPAREN tyfields . RPAREN EQ exp    (rule 19)
   fundec --> FUNCTION ID LPAREN tyfields . RPAREN COLON ID EQ exp    (rule 20)

   default action : Error
   RPAREN : shift and goto state 122


*/
function tigerState113(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 8 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState122(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 114

   exp --> FOR ID ASSIGN exp TO exp . DO exp    (rule 25)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : Error
   DO : shift and goto state 123
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState114(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #2  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #2  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #2  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #2  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #2  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #2  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #2  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #2  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #2  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #2  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #2  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #2  |>
))  29 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState123(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 115

   exp --> IF exp THEN exp ELSE exp .    (rule 22)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 22
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35
   GE : shift and goto state 36
   GT : shift and goto state 37
   LE : shift and goto state 38
   LT : shift and goto state 39
   NEQ : shift and goto state 40
   EQ : shift and goto state 41
   AND : shift and goto state 42
   OR : shift and goto state 43


*/
function tigerState115(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 5 ;
tigerStack[ sp ] := 12; <| tsp | #2 |> )  end


end
/* state 116

   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)
   fieldassign --> ID EQ exp .    (rule 63)

   default action : reduce using rule 63
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState116(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 2 ;
tigerStack[ sp ] := 20; <| tsp | #2 |> )  end


end
/* state 117

   ty --> ARRAY OF . ID    (rule 11)

   default action : Error
   ID : shift and goto state 124


*/
function tigerState117(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState124(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 118

   ty --> LBRACE tyfields . RBRACE    (rule 10)

   default action : Error
   RBRACE : shift and goto state 125


*/
function tigerState118(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 12 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState125(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 119

   vardec --> VAR ID COLON ID ASSIGN . exp    (rule 17)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState119(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState126(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 120

   tyfield --> ID . COLON ID    (rule 16)

   default action : Error
   COLON : shift and goto state 127


*/
function tigerState120(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 5 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState127(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 121

   tyfields --> tyfieldscomma tyfield .    (rule 12)
   tyfieldscomma --> tyfieldscomma tyfield . COMMA    (rule 14)

   default action : reduce using rule 12
   COMMA : shift and goto state 128


*/
function tigerState121(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 4 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState128(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 1 ;
tigerStack[ sp ] := 6; <| tsp | #1 |> )  end


end
/* state 122

   fundec --> FUNCTION ID LPAREN tyfields RPAREN . EQ exp    (rule 19)
   fundec --> FUNCTION ID LPAREN tyfields RPAREN . COLON ID EQ exp    (rule 20)

   default action : Error
   COLON : shift and goto state 130
   EQ : shift and goto state 129


*/
function tigerState122(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState129(s, sp, ts, tsp) | #1  |>
))  5 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState130(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 123

   exp --> FOR ID ASSIGN exp TO exp DO . exp    (rule 25)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState123(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState131(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 124

   ty --> ARRAY OF ID .    (rule 11)

   default action : reduce using rule 11


*/
function tigerState124(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 5; <| tsp | #1 |> )  end


end
/* state 125

   ty --> LBRACE tyfields RBRACE .    (rule 10)

   default action : reduce using rule 10


*/
function tigerState125(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 5; <| tsp | #1 |> )  end


end
/* state 126

   vardec --> VAR ID COLON ID ASSIGN exp .    (rule 17)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 17
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState126(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 5 ;
tigerStack[ sp ] := 9; <| tsp | #2 |> )  end


end
/* state 127

   tyfield --> ID COLON . ID    (rule 16)

   default action : Error
   ID : shift and goto state 132


*/
function tigerState127(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState132(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 128

   tyfieldscomma --> tyfieldscomma tyfield COMMA .    (rule 14)

   default action : reduce using rule 14


*/
function tigerState128(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 7; <| tsp | #1 |> )  end


end
/* state 129

   fundec --> FUNCTION ID LPAREN tyfields RPAREN EQ . exp    (rule 19)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState129(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState133(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 130

   fundec --> FUNCTION ID LPAREN tyfields RPAREN COLON . ID EQ exp    (rule 20)

   default action : Error
   ID : shift and goto state 134


*/
function tigerState130(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState134(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 131

   exp --> FOR ID ASSIGN exp TO exp DO exp .    (rule 25)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 25
   DIVIDE : shift and goto state 32
   TIMES : shift and goto state 33
   PLUS : shift and goto state 34
   MINUS : shift and goto state 35
   GE : shift and goto state 36
   GT : shift and goto state 37
   LE : shift and goto state 38
   LT : shift and goto state 39
   NEQ : shift and goto state 40
   EQ : shift and goto state 41
   AND : shift and goto state 42
   OR : shift and goto state 43


*/
function tigerState131(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 7 ;
tigerStack[ sp ] := 12; <| tsp | #2 |> )  end


end
/* state 132

   tyfield --> ID COLON ID .    (rule 16)

   default action : reduce using rule 16


*/
function tigerState132(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of default ( sp := sp -2;
tigerStack[ sp ] := 8; <| tsp | #1 |> )  end


end
/* state 133

   fundec --> FUNCTION ID LPAREN tyfields RPAREN EQ exp .    (rule 19)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 19
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState133(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 6 ;
tigerStack[ sp ] := 10; <| tsp | #2 |> )  end


end
/* state 134

   fundec --> FUNCTION ID LPAREN tyfields RPAREN COLON ID . EQ exp    (rule 20)

   default action : Error
   EQ : shift and goto state 135


*/
function tigerState134(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState135(s, sp, ts, tsp) | #1  |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 135

   fundec --> FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ . exp    (rule 20)

   default action : Error
   ID : shift and goto state 11
   INT : shift and goto state 10
   STRING : shift and goto state 9
   LPAREN : shift and goto state 8
   IF : shift and goto state 7
   WHILE : shift and goto state 6
   FOR : shift and goto state 5
   LET : shift and goto state 4
   BREAK : shift and goto state 3
   NIL : shift and goto state 2
   MINUS : shift and goto state 1


*/
function tigerState135(s:stack, sp:int, ts:tokenStream, tsp:int): int = 
let 
function goto(tsp:int): int  = case (s[sp]) of
  11 (
<| tigerState16(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  12 (
<| tigerState136(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>   , #1  |>

)  17 (
<| tigerState14(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  21 (
<| tigerState13(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  22 (
<| tigerState12(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>

)  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState1(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  23 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState2(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  22 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState3(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  19 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState4(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  17 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState5(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  16 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState6(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  15 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState7(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  7 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState8(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  3 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState9(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  2 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState10(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  1 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState11(s, sp, ts, tsp) | tigerTsPtr =>  <| goto (tigerTsPtr) |  #1  |>    |>
))  default (print("Error Unknown "); exit(0); 0) end


end
/* state 136

   fundec --> FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp .    (rule 20)
   binop --> exp . PLUS exp    (rule 47)
   binop --> exp . MINUS exp    (rule 48)
   binop --> exp . TIMES exp    (rule 49)
   binop --> exp . DIVIDE exp    (rule 50)
   binop --> exp . LT exp    (rule 51)
   binop --> exp . LE exp    (rule 52)
   binop --> exp . EQ exp    (rule 53)
   binop --> exp . GE exp    (rule 54)
   binop --> exp . GT exp    (rule 55)
   binop --> exp . NEQ exp    (rule 56)
   binop --> exp . AND exp    (rule 57)
   binop --> exp . OR exp    (rule 58)

   default action : reduce using rule 20
   OR : shift and goto state 43
   AND : shift and goto state 42
   EQ : shift and goto state 41
   NEQ : shift and goto state 40
   LT : shift and goto state 39
   LE : shift and goto state 38
   GT : shift and goto state 37
   GE : shift and goto state 36
   MINUS : shift and goto state 35
   PLUS : shift and goto state 34
   TIMES : shift and goto state 33
   DIVIDE : shift and goto state 32


*/
function tigerState136(s:stack, sp:int, ts:tokenStream, tsp:int): int, int = 
let 
function goto(tsp:int): int , int = case (s[sp]) of
  default (print(" Error unknown"); exit(0); 0) end
in case (tigerTS[ tsp ]) of 43 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState32(s, sp, ts, tsp) | #1  |>
))  42 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState33(s, sp, ts, tsp) | #1  |>
))  41 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState34(s, sp, ts, tsp) | #1  |>
))  40 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState35(s, sp, ts, tsp) | #1  |>
))  39 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState36(s, sp, ts, tsp) | #1  |>
))  38 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState37(s, sp, ts, tsp) | #1  |>
))  37 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState38(s, sp, ts, tsp) | #1  |>
))  36 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState39(s, sp, ts, tsp) | #1  |>
))  35 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState40(s, sp, ts, tsp) | #1  |>
))  34 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState41(s, sp, ts, tsp) | #1  |>
))  33 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState42(s, sp, ts, tsp) | #1  |>
))  32 (
( sp := sp + 1; tigerStack[sp] := tigerTS[tsp]; 
tsp := tsp + 1; 
<| tigerState43(s, sp, ts, tsp) | #1  |>
) )default ( sp := sp - 8 ;
tigerStack[ sp ] := 10; <| tsp | #2 |> )  end


end

 in <| tigerState0(tigerStack, tigerStackPtr, tigerTS, tigerTsPtr) | x => print("Finished ") |> end 
